package main

import (  
    "fmt"
    "net"
    "os"
    "io/ioutil"
    "strings" 
    "strconv"	
)

const (  
    HOST = "127.0.0.1"
    PORT = "8080"
    TYPE = "tcp"
    lb = "<"
    rb = ">"  
)
type Filestats struct {
     version int64
     numofbytes int
     exptime int	
}
var files map[string]Filestats

func serverMain(){
  files = make(map[string]Filestats)
  files["test1.txt"] = Filestats {
     0,6,0,
  }
  files["test2.txt"] = Filestats {
     0,8,0,
  }
  files["test3.txt"] = Filestats {
     0,10,0,
  }
  files["test4.txt"] = Filestats {
     0,4,0,
 }
   p, err := net.Listen(TYPE, ":"+PORT)   // Listen for incoming connections.
    if err != nil {
        fmt.Println("Error on listening:", err.Error())
        //os.Exit(1)
    }
    
    defer p.Close()  // Close the listener when the application closes.
    fmt.Println("Listening on " + HOST + ":" + PORT)
 for {
        
        conn, err := p.Accept()  // Listen for an incoming connection.
        if err != nil {
            fmt.Println("Error accepting connections ", err.Error())
            //os.Exit(1)
        }

         go RequestHandler(conn)// Handle request
	
    }
}


func RequestHandler(conn net.Conn) {  
  readbuf := make([]byte, 1024)   // Make a buffer to hold incoming data.
  size, err := conn.Read(readbuf)  // Read the incoming connection into the buffer.
  if err != nil {
    fmt.Println("Error in reading from the read buffer:", err.Error())
  }
   s := string(readbuf[:size])    //Converting into the string
   //p := strings.Fields(s)        //Splitting the string s into the fields in order to extract the Command
   j := strings.Split(s,"\r\n") 
   //fmt.Println(j) 
   p := strings.Split(j[0]," ")
   //fmt.Println(p)
   p[0] = strings.TrimSpace(p[0])	
  if p[0] == "read"{
   data, err := ioutil.ReadFile(strings.TrimSpace(p[1]))   //Reading the file,the filename is in the p[1]
     if err != nil {
         
            conn.Write([]byte("ERR_FILE_NOT_FOUND\n"))    //Sending the error message on the channel to the client
              
             //os.Exit(1)
     } 
    p[1]=strings.TrimSpace(p[1])
    conn.Write([]byte("CONTENTS "))
    conn.Write([]byte(lb + strconv.FormatInt(files[p[1]].version,10) + rb + " ")) 
    conn.Write([]byte(lb + strconv.Itoa(files[p[1]].numofbytes) + rb + " "))
    conn.Write([]byte(lb + strconv.Itoa(files[p[1]].exptime) + rb + "\r\n")) 
    conn.Write([]byte("\n")) 
    conn.Write([]byte(data)) // Write the file content in the connection channel.
    conn.Write([]byte("\r\n"+"\n"))
     }else if p[0] == "write"{
           
          z := strings.Split(s,"\r\n")
          q := strings.Split(z[0]," ")
         if _, err := os.Stat(p[1]); err == nil {
	 
         ioutil.WriteFile(p[1],[]byte(z[1]),0777)    
		b, _ := strconv.Atoi(q[2])
		expt,_ := strconv.Atoi(q[3])
               
              files[p[1]] = Filestats {
                  0,b,expt,
               }       	   
             
             s := strconv.FormatInt(files[p[1]].version,10)
           conn.Write([]byte("OK" + " " + "<" + s + ">"))         
         } else {
          ioutil.WriteFile(q[1],[]byte(z[1]),0777)   //r=4,w=2,x=1,If the file exists then data is written into it else the file
						                                        //is created with the permission 777 and then the data is written into it		
                 b, _ := strconv.Atoi(q[2])
		 expt , _ := strconv.Atoi(q[3])                 
		           
                    
                  files[q[1]] = Filestats {
                   0,b,expt,
                  } 
                      
		s := strconv.FormatInt(files[q[1]].version,10)     
		conn.Write([]byte("OK" + " " + "<" + s + ">" + "\r\n" + "\n"))
	                                              //cas <filename> <version> <numbytes> [<exptime>]\r\n
                                               //<content bytes>\r\n
          } 	   
     }else if p[0] == "cas"{
         
      if _, err := os.Stat(p[1]); err == nil {
              z := strings.Split(s,"\r\n")
              q := strings.Split(z[0]," ")
              s := strconv.FormatInt(files[q[1]].version,10)
               if s == strings.TrimSpace(q[2]){
                   ioutil.WriteFile(q[1],[]byte(z[1]),0777)
                     v := files[q[1]].version
                     b,_ := strconv.Atoi(strings.TrimSpace(q[3]))          //numofbytes
                     e,_ := strconv.Atoi(strings.TrimSpace(q[4]))           //exptime
                     delete(files,q[1])
                     v=v+1                             //Updating the version
                    files[q[1]] = Filestats {            //Creating a new entry for the file in the map
                   v,b,e,
                  } 
                  s1 := strconv.FormatInt(files[q[1]].version,10)     
                  conn.Write([]byte("OK" + " " + "<" + s1 + ">" + "\r\n" + "\n"))

               }else {
                   conn.Write([]byte("ERR_VERSION\n"))
               }


      }else{
           conn.Write([]byte("ERR_FILE_NOT_FOUND\n"))    
                 
      }

     }else if p[0] == "delete"{
         if _, err := os.Stat(p[1]); err == nil{
             os.Remove(p[1])
              conn.Write([]byte("OK" + "\r\n" + "\n")) 

         }else{
            conn.Write([]byte("ERR_FILE_NOT_FOUND\n"))
         } 


  
     }
  // Close the connection when you're done with it.
  conn.Close()


}
func main() {  
   serverMain()    //Calling FileServer 
}


