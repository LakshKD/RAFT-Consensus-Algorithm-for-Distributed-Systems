package main

import(
    
     "fmt"
     "io/ioutil"
     "strings"
     "strconv"
     "testing"
      "time"
     
     //cluster "github.com/cs733-iitb/cluster"
     //log1 "github.com/cs733-iitb/log"
  )



func makeRafts() []Node {
	var RaftNodeObj []Node

	RaftNode_obj[0] = New(1, "cluster_test_config1.json")
	RaftNode_obj[1] = New(2, "cluster_test_config1.json")
	RaftNode_obj[2] = New(3, "cluster_test_config1.json")
	RaftNode_obj[3] = New(4, "cluster_test_config1.json")
	RaftNode_obj[4] = New(5, "cluster_test_config1.json")

	return RaftNodeObj

}

func getLeader(RaftNodeObj []Node) Node {

	idcountarray := [6]int{0, 0, 0, 0, 0, 0}

	for i := 0; i <= 5; i++ {
		p = RaftNodeObj[i].LeaderID()
		idcountarray[p]++
	}
	max := idcountarray[0]
	index := 0
	for j := 1; j <= 5; j++ {
		if idcountarray[j] > max {
			index = j
		}
	}

	for k := 0; k <= 4; k++ {
		if RafNodeObj[k].config.Id == index {
			return RaftNodeObj[k]
		}

	}

}



// Simple serial check of getting and setting
func NodeTest(t *testing.T) {
	//peers, err := cluster.New(1, "cluster_test_config1.json")

	rafts := makeRafts() // array of []raft.Node
	fmt.Println("abc")
	ldr := getLeader(rafts)

	ldr.Append("foo")
	time.Sleep(1 * time.Second)
	for _, node := range rafts {
	select {
	// to avoid blocking on channel.
	case ci := <-node.CommitChannel():
		if ci.Err != nil {
			t.Fatal(ci.Err)
		}
		if string(ci.Data) != "foo" {
			t.Fatal("Got different data")
		}
	default:
		t.Fatal("Expected message on all nodes")
	}
}
}

// Useful testing function
func expect(t *testing.T, a string, b string) {
	if a != b {
		t.Error(fmt.Sprintf("Expected %v, found %v", b, a)) // t.Error is visible when running `go test -verbose`
	}
}
